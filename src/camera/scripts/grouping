콘텐츠로 건너뛰기
나의 말:
autonav@autonav-Z790-AORUS-ELITE:~/catkin_ws/src/wonjung/src/camera/scripts$ rosrun camera_
camera_calibration          camera_info_manager
camera_calibration_parsers  
autonav@autonav-Z790-AORUS-ELITE:~/catkin_ws/src/wonjung/src/camera/scripts$ ls
find_hsv.py  grouping.py  HW4.py  original_vanishing_point.py
autonav@autonav-Z790-AORUS-ELITE:~/catkin_ws/src/wonjung/src/camera/scripts$ 

scripts 디렉토리에 있는 grouping.py 실행시키려고 하는데 rosrun 명령어 다음에 camera 패키지가 안 나와. 이게 무슨 상황이지?
ChatGPT의 말:
좋은 질문이에요 — 이건 ROS 패키지 인식 문제입니다.
현재 상황을 보면 rosrun 뒤에 camera_까지만 치면 자동완성이 되는데, camera 패키지가 목록에 뜨지 않고 camera_calibration, camera_info_manager, camera_calibration_parsers 등만 보이죠.
즉, ROS가 camera라는 패키지를 인식하지 못하고 있습니다.

🔍 원인 분석
가능한 원인은 다음과 같습니다:

패키지가 catkin_make로 빌드되지 않음

wonjung 아래의 camera 폴더가 단순히 소스 코드 디렉토리일 뿐, package.xml과 CMakeLists.txt가 없거나, catkin_make 이후 빌드되지 않았을 수 있습니다.

rosrun은 오직 ROS 패키지 단위로 실행할 수 있으므로, camera가 ROS 패키지로 인식되어야 합니다.

환경 변수 갱신이 안 됨

빌드를 해도 source devel/setup.bash를 하지 않으면 ROS 환경에 반영되지 않습니다.

패키지 이름이 실제로 다름

package.xml의 <name> 필드가 camera가 아닐 수도 있습니다.

예를 들어 <name>camera_test</name>이면 rosrun camera_test grouping.py로 실행해야 합니다.

🧩 해결 방법
camera 폴더가 ROS 패키지인지 확인

cd ~/catkin_ws/src/wonjung/src/camera
ls
여기서 **package.xml과 CMakeLists.txt**가 있어야 합니다.
없다면 camera는 ROS 패키지가 아니므로 rosrun으로 실행할 수 없습니다.
이 경우 그냥 Python으로 직접 실행해야 합니다:

python3 grouping.py
패키지가 맞다면 빌드 후 환경 설정

cd ~/catkin_ws
catkin_make
source devel/setup.bash
패키지 이름 확인

grep "<name>" ~/catkin_ws/src/wonjung/src/camera/package.xml
예를 들어 결과가 <name>camera_pkg</name>라면,

rosrun camera_pkg grouping.py
이렇게 실행해야 합니다.

✅ 요약
문제	원인	해결 방법
rosrun camera 안 됨	camera가 ROS 패키지 아님	그냥 python3 grouping.py로 실행
camera가 패키지인데 rosrun 안 됨	빌드/환경 미갱신	catkin_make → source devel/setup.bash
패키지 이름 불일치	package.xml 이름 다름	실제 <name>으로 실행
원하신다면, ~/catkin_ws/src/wonjung/src/camera 안의 파일 목록(ls -l)을 보여주시면
정확히 ROS 패키지 구조인지 판별해드릴 수 있습니다.
그걸 보면 rosrun 가능한지, 아니면 그냥 python3로 돌려야 하는지 바로 알 수 있어요.

나의 말:
rosrun으로 되던 게 왜 갑자기 안되지
ChatGPT의 말:

20s 동안 생각함
지금 상황만 보면 ROS가 네 camera 패키지를 “패키지 목록”에서 아예 못 보고 있는 상태라서 그래요.
그래서 rosrun camera_ 치면 시스템에 원래부터 있던 camera_calibration 이런 것만 뜨는 거고, 네가 만든 camera는 안 나오는 거고요.

예전에는 됐는데 갑자기 안 되는 전형적인 이유는 거의 세 가지입니다:

1️⃣ 새 터미널에서 setup.bash 안 읽음 (가장 흔함)
보통 이 케이스가 제일 많아요.

예전에는:

source ~/catkin_ws/devel/setup.bash 한 터미널에서 작업

→ 그래서 camera 패키지가 ROS에 잘 보였음

지금은:

새 터미널 열었는데 source ~/catkin_ws/devel/setup.bash를 안 함

또는 .bashrc가 바뀌어서 자동으로 안 불리고 있음

→ 그래서 /opt/ros/...에 있는 기본 패키지들만 보이는 상태

그래서 자동완성할 때
camera_calibration, camera_info_manager 같은 것만 나오는 거예요.

🔧 이 경우 해결
터미널에서:

cd ~/catkin_ws
catkin_make        # (빌드가 이미 되어 있으면 건너뛰어도 됨)
source devel/setup.bash
그리고 다시:

rosrun camera grouping.py
이게 되면 “아, 그냥 환경만 안 잡혀 있었구나”인 겁니다.

.bashrc에 아래 두 줄이 있는지도 한 번 확인해 보면 좋아요:

source /opt/ros/noetic/setup.bash
source ~/catkin_ws/devel/setup.bash
없으면 추가해두면 앞으로는 새 터미널 열어도 자동으로 잡혀요.

2️⃣ 워크스페이스가 달라졌거나, 패키지를 다른 곳으로 옮김
예를 들어:

예전에는 morai_ws에서 작업했는데
지금은 catkin_ws만 source 해 둔 상태라든지,

camera 폴더를 ~/catkin_ws/src 밖 어딘가로 옮겼다든지

이러면 ROS 입장에서는:

“그 패키지? 내 ROS_PACKAGE_PATH 안에 없는데?”

가 돼서 rosrun 자동완성 목록에도 안 나옵니다.

🔧 여기서 할 수 있는 체크들
터미널에서:

echo $ROS_PACKAGE_PATH
여기에 ~/catkin_ws/src가 포함되어 있어야 하고,
그 안쪽 어딘가에 camera 패키지가 있어야 합니다.

그리고:

rospack list | grep camera
했을 때 예전에 되던 환경에서는 아마

camera   /home/사용자이름/catkin_ws/src/...
이런 식으로 나왔을 텐데,
지금은 그 줄이 통째로 사라졌을 가능성이 큽니다.

3️⃣ camera 패키지 자체가 깨졌거나 이름이 바뀜
혹시:

camera 디렉토리 안의 package.xml을 실수로 지웠다거나,

<name>camera</name> 부분을 다른 이름으로 바꿨다거나,

camera 폴더를 통째로 다른 이름으로 변경했다면

ROS 입장에선 그건 더 이상 camera라는 패키지가 아님입니다.

🔧 이 경우 확인
cd ~/catkin_ws/src/wonjung/src/camera
ls
여기에 반드시 두 개 있어야 함:

package.xml

CMakeLists.txt

그리고 package.xml에서:

grep "<name>" package.xml
예를 들어 결과가:

<name>camera_test</name>
이렇게 나오면, 실행은 이렇게 해야 합니다:

rosrun camera_test grouping.py
즉, **rosrun에 쓰는 이름은 디렉토리 이름이 아니라 package.xml의 <name>**이에요.

💡 정리하면
“예전에 되던 rosrun이 갑자기 안 되는 것”은 대부분:

새 터미널에서 source ~/catkin_ws/devel/setup.bash 안 함

다른 워크스페이스/환경을 source함

패키지 구조나 이름이 바뀜 (package.xml, <name>)

이 셋 중 하나입니다.

일단 아래 순서대로 시도해보면 좋아요:

cd ~/catkin_ws
catkin_make                # (에러 나면 그것부터 해결)
source devel/setup.bash
rospack list | grep camera
rosrun camera grouping.py  # 혹은 package.xml에 적힌 이름으로
실행했을 때 나오는 에러 메시지/결과를 그대로 복사해서 보내주면,
거기서부터 딱 짚어서 어디가 문제인지 같이 봐줄게요.

나의 말:
셋 다 정상적으로 되어 있는 데도 안돼
ChatGPT의 말:

45s 동안 생각함
아 이거, 설명해주신 로그를 다시 보니까 약간 착각하기 쉬운 포인트가 하나 있어요.

autonav@...$ rosrun camera_
camera_calibration          camera_info_manager
camera_calibration_parsers  
여기서 문제는…

rosrun camera_ 까지 쳐놓고 탭 자동완성 보고 있는 것 자체가 문제예요 😂

camera 패키지가 있다고 해도,
이미 camera_까지 쳐놓은 상태에서는
이 prefix(접두어)에 맞는 패키지들만 나옵니다.

camera_calibration ✅ (camera_로 시작함)

camera_info_manager ✅ (camera_로 시작함)

camera_calibration_parsers ✅

camera ❌ (camera_로 시작 안 함)

그래서 camera 패키지가 정상이어도
rosrun camera_ + TAB에서는 절대 안 나타나는 게 정상이에요.

즉, 자동완성에 안 나오는 것만으로는 패키지가 안 잡힌다는 증거가 아닙니다.

1️⃣ 먼저 이렇게 실행해봐요
그냥 깔끔하게 이렇게 쳐보세요:

rosrun camera grouping.py
(뒤에 언더바 _ 절대 붙이지 말고요!)

혹은 패키지 이름이 camera가 아니라면
package.xml에 있는 <name> 기준으로:

rosrun <패키지이름> grouping.py
자동완성은 잠시 잊고, 그냥 직접 쳐서 실행이 되는지가 제일 중요해요.

2️⃣ 그래도 안 되면, 아주 빠른 체크 3줄
터미널에서:

rospack find camera
경로가 나오면 → ROS가 camera 패키지는 보고 있다는 뜻

package 'camera' not found 나오면 → 워크스페이스/소스 문제가 아직 있는 거고요.

그다음:

roscd camera
ls
여기서 scripts/ 안에 grouping.py가 있는지 보고,

cd scripts
ls -l grouping.py
권한이 -rwxr-xr-x 처럼 x(실행권한)가 있어야 합니다.

없으면:

chmod +x grouping.py
그리고 다시:

rosrun camera grouping.py
3️⃣ 자동완성 쓸 때 팁
패키지 이름 자동완성 쓰려면:

rosrun cam<TAB>
처럼 cam까지만 입력하고 탭을 눌러야
camera, camera_calibration 등이 같이 후보로 떠요.

camera_처럼 언더바까지 쳐버리면
그걸로 시작하는 것만 필터링되어서
정작 camera는 리스트에서 빠지는 게 정상 동작입니다.

정리하면
rosrun camera_ → 애초에 camera는 자동완성 후보에 안 나오는 게 정상

진짜 되는지 보려면:
👉 rosrun camera grouping.py 직접 실행해서 에러 메시지를 보는 게 핵심

혹시 저 명령 쳤을 때 나오는 에러 문구를 그대로 붙여주면,
그걸 기준으로 정확히 어디서 막히는지 바로 짚어줄 수 있어요.

나의 말:
def grouping(roi, lines): 
# def grouping(roi, lines, angle_l=12.0, x_l=40): 
    group_list = []
    
    for line in lines:
        x1, y1, x2, y2 = line[0]

        slope = (y2 - y1)/(x2 - x1 + 1e-6) # -> 왼쪽 차선 slope < 0
        angle = np.degrees(np.arctan(slope)) 
        y_intercept = y1 - slope * x1 # y1 = slope * x1 + y_intercept
        x_intercept = y_intercept / (slope + 1e-6) # 화면 아래 x값으로 설정해야. 

        if slope != 0:
        
            if (18 < abs(angle) < 70):

                #print("x1: ",x1, ", y1: ",y1, ", x2: ", x2, ", y2: ", y2)

                similar = False
                for group in group_list:
                    if (group[0]['slope'] * slope) > 0 and abs(group[0]['angle']-angle) < 12.0 and abs(group[0]['x_intercept']-x_intercept) < 40:
                        group.append({'slope': slope, 'angle': angle, 'x_intercept': x_intercept,'y_intercept': y_intercept, 'pos': (x1, y1, x2, y2)})
                        similar = True
                        break # 반복문 전체를 즉시 종료
                
                if not similar:
                    group_list.append([{'slope': slope, 'angle': angle, 'x_intercept': x_intercept, 'y_intercept': y_intercept, 'pos': (x1, y1, x2, y2)}])

    return group_list
여기서 x값을 y=0 일 때 말고 roi 화면의 맨 아래쪽 x값을 읽어오려면 어떻게 해야하지?
ChatGPT의 말:
좋은 질문이에요 👍
지금 코드에서

x_intercept = y_intercept / (slope + 1e-6)
이 부분은 사실상 “y = 0일 때의 x값”, 즉 y축과의 교점을 구하는 식이에요.
그런데 당신이 원하는 건 **ROI 영역의 맨 아래쪽(y = roi의 높이)**에서의 x값이에요.

✅ 수정 방법
ROI의 이미지 높이를 알고 있으므로 (예: roi.shape[0]),
그 y값을 직선 방정식에 대입하면 됩니다.

직선식이

y
=
s
l
o
p
e
×
x
+
y
_
i
n
t
e
r
c
e
p
t
y=slope×x+y_intercept
이므로, y를 roi의 맨 아래(y = roi.shape[0])로 두고
x를 구하면 됩니다.

x
=
y
−
y
_
i
n
t
e
r
c
e
p
t
s
l
o
p
e
x= 
slope
y−y_intercept
​
 
🔧 코드 수정 예시
def grouping(roi, lines): 
    group_list = []
    
    height = roi.shape[0]  # ROI의 세로 길이 (맨 아래 y값)
    
    for line in lines:
        x1, y1, x2, y2 = line[0]

        slope = (y2 - y1) / (x2 - x1 + 1e-6)
        angle = np.degrees(np.arctan(slope)) 
        y_intercept = y1 - slope * x1
        
        # y=0일 때 x값 대신, y=roi의 맨 아래일 때 x값 계산
        x_intercept_bottom = (height - y_intercept) / (slope + 1e-6)

        if slope != 0:
            if (18 < abs(angle) < 70):
                similar = False
                for group in group_list:
                    if (group[0]['slope'] * slope) > 0 and abs(group[0]['angle'] - angle) < 12.0 and abs(group[0]['x_intercept'] - x_intercept_bottom) < 40:
                        group.append({
                            'slope': slope,
                            'angle': angle,
                            'x_intercept': x_intercept_bottom,
                            'y_intercept': y_intercept,
                            'pos': (x1, y1, x2, y2)
                        })
                        similar = True
                        break
                
                if not similar:
                    group_list.append([{
                        'slope': slope,
                        'angle': angle,
                        'x_intercept': x_intercept_bottom,
                        'y_intercept': y_intercept,
                        'pos': (x1, y1, x2, y2)
                    }])

    return group_list
🧠 요약
구분	계산식	의미
기존 코드	x_intercept = y_intercept / slope	y=0일 때의 x (y축 교점)
수정 코드	x_intercept_bottom = (height - y_intercept) / slope	ROI 맨 아래(y=height)일 때의 x
이렇게 바꾸면, 각 선의 “화면 아래쪽 x위치” 기준으로 그룹핑이 이루어집니다.
즉, 실제 영상 하단에서 왼쪽/오른쪽 차선이 얼마나 떨어져 있는지를 더 정확하게 반영하게 돼요.

나의 말:
def grouping(roi, lines): 
# def grouping(roi, lines, angle_l=12.0, x_l=40): 
    group_list = []
    
    for line in lines:
        x1, y1, x2, y2 = line[0]

        slope = (y2 - y1)/(x2 - x1 + 1e-6) # -> 왼쪽 차선 slope < 0
        angle = np.degrees(np.arctan(slope)) 
        y_intercept = y1 - slope * x1 # y1 = slope * x1 + y_intercept
        # x_intercept = y_intercept / (slope + 1e-6) # 화면 아래 x값으로 설정해야. 
        h, w = roi.shape[:2]
        # h : roi의 높이
        # h - 1 : roi 안에서 가장 아래
        # 배열 인덱스는 0부터 시작하는데, ROI의 높이가 480이라면 픽셀의 y좌표 인덱스는 0 ~ 479 
        # 그래서 가장 아래쪽 행의 인덱스는 479 = 480 - 1 = roi.shape[0] - 1 = h -1
        y_max = h - 1
        x_under = (y_max - y_intercept) / slope # 화면 아래 x값


        if slope != 0:
        
            if (18 < abs(angle) < 70):

                #print("x1: ",x1, ", y1: ",y1, ", x2: ", x2, ", y2: ", y2)
                print("x_under: ", x_under)
                # y값도 나오는데...? 

이걸 프린트 했을 때 y값도 나오는 이유가 뭐지

ef hough(roi, edges): # 완료
    
    #return lines
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=30, minLineLength=10, maxLineGap=10)
    # 짧은 blue 안 잡힘 : threshold = 30, min = 30, max = 10
    # 짧은 white 잡힘 : threshold = 30, min = 10, max = 10 (blue는 깜빡거림)

허프라인을 이렇게 설정하긴 했어도 
x_under:  560.0816340612245
x_under:  89.33332746666667
x_under:  73.99998400000003
x_under:  56.31034451724135
x_under:  562.9655183793104
x_under:  595.000001
x_under:  76.14283857142861
x_under:  95.25925896296293
x_under:  56.11111074074074
x_under:  595.5384640961538
x_under:  58.999993500000016
x_under:  561.5247535643565
x_under:  92.624984125
x값이 50대가 나올 수는 없어 50은 y값인데.
